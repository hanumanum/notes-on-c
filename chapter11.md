# Զրույց տասնմեկերորդ

Այս զրույցում ես պատմում եմ, թե ինչպես ստեղծել _դինամիկ_ և _ստատիկ_ գրադարաններ, ապա դրանք օգտագործել ծրագրում։ Եվ քանի որ նպատակս գրադարաններ ստեղծման տեխնիկայի ցուցադրումն է, շատ բարդ բաների հետևից չեմ ընկնի և որպես օրինակ կներկայացնեմ միայն մեկ ֆունկցիա պարունակող գրադարան։ _{հետագայում տեքստն ընդլայնել մի քանի ֆայլերից բաղկացած օրինակի համար}_

Ստեղծեմ `ni.c` (numeric integral) ֆայլը, որը պարունակում է գրադարանի իրականացումը։ Այս ֆայլում սահմանված են մոտավոր ինտեգրալի հաշվման Սիմպսոնի բանաձևը՝ `simpson` ֆունկցիան, թվի բացարձակ արժեքը հաշվող `dabs` ֆունկցիան և `epsilon` հաստատունը, որի օգնությամբ որոշվում է հաշվարկների ճշտությունը։

```c
static const double epsilon = 1e-5;

static double dabs( double v )
{
  return (v < 0 ? -v : v);
}

static double simpson( double(*f)(double), double a, double b )
{
  return ((b - a) / 6) * (f(a) + 4 * f((a + b) / 2) + f(b));
}
```

Այս երեք անունների սահմանումն էլ սկսվում են `static` ծառայողական բառով՝ ցույց տալու, որ նրանք պետք է տեսանելի լինեն միայն `ni.c՝ կոմպիլյացվող միավորի սահմանում։ _{մանրամասներ linker-ի մասին}_

Գրադարանի իրականացման `ni.c` ֆայլում սահմանված է նաև `integral` ֆունկցիան, որը «բաժանիր և տիրիր» մոտեցմամբ հաշվում է ինտեգրալը։ Եթե ինտեգրման միջակայքի երկարությունը փոքր է նախապես սահմանված `epsilon` թվից, ապա այդ հատվածի վրա կիրառվում է Սիմպսոնի բանաձևը։ Հակառակ դեպքում միջակայքը տրոհվում է երկու հավասար մասերի և մասերից ամեն մեկի վրա ռեկուրսիվ կիրառվում է `integral` ֆունկցիան՝ որպես արդյունք վերադարձնելով ստացված գումարը։ _{վերաձևակերպել անհաջող նախադասությունը}_

```c
double integral( double(*f)(double), double a, double b )
{
  if( b - a < epsilon )
    return simpson( f, a, b );
  double m = (a + b) / 2.0;
  return integral( f, a, m ) + integral( f, m, b );
}
```

Որպեսզի այս ֆունկցիան հնարավոր լինի օգտագործել այլ ծրագրերում, ստեղծեմ նաև `ni.h` հայտարարությունների ֆայլը։ Այն պարունակելու է միայն `integral` ֆունկցիայի հայտարարությունը։

```c
#ifndef NUMERIC_INTEGRAL
#define NUMERIC_INTEGRAL

extern double integral( double(*)(double), double, double );

#endif
```

Ֆունկցիայի հայտարարությունից առաջ գրված `extern` ծառայողական բառն ուզում է ասել, թե `integral` ֆունկցիան սահմանված է մի որևէ այլ տեղ (գուցե հենց նույն ֆայլում)։

_{ստատիկ ու դինամիկ կապակցման մասին}_

Նախ ցույց տամ, թե ինչպես պետք է `ni.c` ֆայլից ստանալ ստատիկ գրադարան։ Դրա համար պետք է ֆայլը կոմպիլյացնել և ստեղծել _օբյեկտային ֆայլ_, այնուհետև օբյեկտային ֆայլից (կամ ֆայլերից, եթե դրանք մի քանի հատ են) ստանալ ստատիկ գրադարանի արխիվը։

`.c` ֆայլը կոմպիլյացնելու և համապատասխան օբյեկտային ֆայլը ստանալու համար կոմպիլյատորը պետք է աշխատեցնել `-c` պարամետրով։

```bash
$ gcc -c ni.c -o ni.o
```

Ստատիկ գրադարանի ֆայլը, որի անունը պետք է ունենա `lib` նախածանցը, իսկ ընդլայնումը պետք է լինի `.a`, ստեղծվում է `ar`արխիվացման ծրագրի օգնությամբ։

```bash
$ ar rcs libni.a ni.o
```

Հիմա ցույց տամ, թե ինչպես եմ այս գրադարանն օգտագործելու։ Ենթադրենք ուզում եմ `-1..1` միջակայքի վրա հաշվել _x²_ և _x³_ ֆունկցիաների մոտավոր ինտեգրալը։ Ստեղծեմ `ex0.c` ֆայլը հետևյալ պարունակությամբ։

```c
#include <stdio.h>
#include "ni.h"

double sqr(double x) { return x * x; }
double cub(double x) { return x * x * x; }

int main()
{
  double r0 = integral( &sqr, -1, 1 );
  printf( "> %lf\n", r0 );
  double r1 = integral( &cub, -1, 1 );
  printf( "> %lf\n", r1 );
  return 0;
}
```

Այստեղ օգտագործել եմ `ni` (numeric integral) գրադարանի միակ `integral` ֆունկցիան։ Սա նշանակում է, որ `ex0.c` ֆայլի կոմպիլյացիայի և կապակցման ժամանակ պետք է կապերի խմբագրիչին հուշել `ni` գրադարանի մասին, նաև `-static` պարամետրով նշել, որ կատարվելու է ստատիկ կապակցում։

```bash
$ gcc -o exs ex0.c -lni -static
```

Այս հրամանի կատարումից հետո արտածվում է հաղորդագրություն, որում ասվում է, թե կապերի խմբագրիչը չի գտել `ni` գրադարանը։

```
/usr/bin/ld: cannot find -lni
collect2: error: ld returned 1 exit status
```

Բանն այն է, որ `-l` պարամետրով նշված գրադարանները որոնվում են կապերի խմբագրիչին նախապես հայտնի կոնկրետ տեղերում։ Որպեսզի որոնման ճանապարհներում ներառվեն նաև լրացուցիչ պանակներ, դրանք պետք է թվարկել կոմպիլյացիայի (և կապակցման) հրամանի `-L` պարամետրով։ Իմ օրինակում պարզապես պետք է նշել ընթացիկ պանակը։

```bash
$ gcc -o exs ex0.c -Լ․ -lni -static
```

Արդեն կարող եմ գործարկել `exs` մոդուլը և համոզվել, որ այն աշխատում է իմ սպասածի պես։

Անցնեմ առաջ ու պատմեմ դինամիկ (shared) գրադարան ստեղծելու մասին։ *Դինամիկ* գրադարան ստեղծելու համար C լեզվի կոմպիլյատորին պետք է հրահանգել, որ գեներացնի *տեղաբաշխումից անկախ կոդով* (position-independent code - PIC) օբյեկտային ֆայլ։ Սա նշանակում է, որ այդպիսի կոդը կարող է առանց փոփոխության կատարվել՝ բեռնվելով հիշողության կամայական տիրույթում։ PIC կոդ գեներացնելու համար կոմպիլյատորին պետք է տալ `-fpic` հրահանգը։ Ոչ PIC կոդով օբյեկտային ֆայլից տարբերելու համար PIC կոդով օբյեկտային ֆայլին հաճախ տալիս են `.lo` ընդլայնումը։

```bash
$ gcc -c -fpic ni.c -o ni.lo
```

Այնուհետև `ni.lo` օբյեկտային ֆայլից պետք է կառուցել `lib` նախածանց և `.so` ընդլայնում ունեցող դինամիկ գրադարանի ֆայլը։

```bash
$ gcc -shared -o libni.so ni.lo
```




